/******************************************************************************
 *                                                                            *
 * Copyright (C) 2003 Michal Czakon                                           *
 *                                                                            *
 ******************************************************************************/

#include <IdSolver.hpp>
#include <sys/stat.h>

/******************************************************************************
 *                                                                            *
 * constructor                                                                *
 *                                                                            *
 ******************************************************************************/

IntegralMap::IntegralMap(const string& database_suffix) : 
  _options(SolveNumerators),
  _database_suffix(database_suffix),
  _n_assigned_integrals(0),
  _n_unassigned_integrals(0)
{}

/******************************************************************************
 *                                                                            *
 * destructor                                                                 *
 *                                                                            *
 ******************************************************************************/

/**
 *
 * Needed to safely erase integrals and associated expressions in the right
 * order.
 *
 */

IntegralMap::~IntegralMap()
{
  bool removed;

  do
    {
      removed = false;

      for (IdentifierPtr id=_identifiers.begin(); id!=_identifiers.end(); ++id)
	for (IntegralPtr i = id.entry()._integrals.begin(); 
	     i != id.entry()._integrals.end(); ++i)
	  {
	    if (!i.entry()._ref_count)
	      {
		if (i.entry().assigned()) --_n_assigned_integrals;
		else --_n_unassigned_integrals;
		id.entry()._integrals.erase(i);
		removed = true;
		break;
	      }
	  }
    }
  while (removed);
}

/******************************************************************************
 *                                                                            *
 * read                                                                       *
 *                                                                            *
 ******************************************************************************/

/**
 *
 * Read integrals and their respective values from a stream. The input format
 * has to be the same as that generated by print().
 *
 */

void
IntegralMap::read(istream& input)
{
  while (input)
    {
      string buffer;

      getline(input, buffer, '=');
      int begin = buffer.find("fill")+4, end;

      if ((begin = buffer.find_first_not_of("\n\t ",begin)) == string::npos ||
	  (end = buffer.find(")", begin)) == string::npos) break;

      Integral i = integral(buffer.substr(begin, end-begin+1));

      getline(input, buffer, ';');
      i.assign(expression(buffer));
    }
}

/******************************************************************************
 *                                                                            *
 * integral                                                                   *
 *                                                                            *
 ******************************************************************************/

/**
 *
 * The input integral has to have the form
 *
 * identifier(power1,...,powern)
 *
 * e.g.
 *
 * PR0(1,1,1,0)
 *
 */

Integral
IntegralMap::integral(const string& input)
{
  // parse the identifier

  int begin = input.find_first_not_of("\n\t ");
  int end = input.find("(", begin);

  if (end == string::npos)
    {
      cerr << "Integral::Integral: \"" << input 
	   << "\" could not identify integral" << endl;

      exit(1);
    }

  const string str(input, begin, end-begin);
  const pair<string, IdentifierEntry> id_entry(str, IdentifierEntry(*this));
  pair<IdentifierPtr, bool> id_insert_stat = _identifiers.insert(id_entry);
  IdentifierPtr& id = id_insert_stat.first;
  
  // if the identifier has not been enocuntered yet, try to open a
  // database of associated integrals. The name is hardcoded to be 
  // <identifier>_database_suffix. The database is not created if it doesn't
  // exist.

  struct stat buf;
  if (id_insert_stat.second && !stat((str+_database_suffix).c_str(), &buf))
    {
      try
	{
	  id.entry()._db = 
	    new DB((str+_database_suffix).c_str(), DATABASE::OWRITER);
	}
      catch (DATABASE_ERROR e)
	{
	  cerr << "IntegralMap::integral: " << str+_database_suffix << " "
	       << e << endl;
	  exit(1);
	}
    }
  
  // parse the list of powers

  IntegralPowers pow;
  begin = end+1;

  do
    {
      end = input.find_first_of(",)", begin);
      string n(input, begin, end-begin);
      pow.push_back(atoi(n.c_str()));
      begin = end+1;
    }
  while (end != string::npos && input[end] != ')');

  if (end == string::npos)
    {
      cerr << "Integral::Integral: \"" << input
	   << "\" missing closing parenthesis" << endl;

      exit(1);
    }

  const pair<IntegralPowers, IntegralEntry> i_entry(pow, IntegralEntry(id));
  pair<IntegralPtr, bool> i_insert_stat = id.entry()._integrals.insert(i_entry);
  IntegralPtr& i = i_insert_stat.first;

  if (i_insert_stat.second)
    {
      ++_n_unassigned_integrals;

      if (id.entry()._db)
	{
	  int8* powers = new int8[i.powers().size()];
	  int8* ptr = powers;
	  for (IntegralPowers::const_iterator p = i.powers().begin();
	       p != i.powers().end(); ++p, ++ptr) *ptr = *p;
	  
	  try
	    {
	      int value_size;
	      int8* value = 
		id.entry()._db->get(powers, i.powers().size(),0,-1,&value_size);
	      i.entry().assign(expression(value, value_size));
	      free(value);
	      i.entry()._stored = true;
	    }
	  catch (DATABASE_ERROR e)
	    {
	      if (e.code() != DATABASE::ENOITEM)
		{
		  cerr << "IntegralMap::integral: " << str+_database_suffix
		       << " " << e << endl;
		  exit(1);
		}
	    }
	  
	  delete[] powers;
	}
    }

  return Integral(i);
}

Integral
IntegralMap::integral(const char* buffer, int size)
{
  // first comes the identifier
  
  const pair<string, IdentifierEntry> id_entry(buffer, IdentifierEntry(*this));
  pair<IdentifierPtr, bool> id_insert_stat = _identifiers.insert(id_entry);
  IdentifierPtr& id = id_insert_stat.first;
  
  // if the identifier has not been enocuntered yet, try to open a
  // database of associated integrals. The name is hardcoded to be 
  // <identifier>_database_suffix. The database is not created if it doesn't
  // exist.

  struct stat buf;
  if (id_insert_stat.second && !stat((id.str()+_database_suffix).c_str(), &buf))
    {
      try
	{
	  id.entry()._db = 
	    new DB((id.str()+_database_suffix).c_str(),DATABASE::OWRITER);
	}
      catch (DATABASE_ERROR e)
	{
	  cerr << "IntegralMap::integral: " << id.str()+_database_suffix << " "
	       << e << endl;
	  exit(1);
	}
    }
  
  // then the list of powers

  IntegralPowers pow;
  const Power* end = buffer+size;
  for (const Power* p= buffer+strlen(buffer)+1; p < end; ++p) pow.push_back(*p);

  const pair<IntegralPowers, IntegralEntry> i_entry(pow, IntegralEntry(id));
  pair<IntegralPtr, bool> i_insert_stat = id.entry()._integrals.insert(i_entry);
  IntegralPtr& i = i_insert_stat.first;

  if (i_insert_stat.second)
    {
      ++_n_unassigned_integrals;

      if (id.entry()._db)
	{
	  int8* powers = new int8[i.powers().size()];
	  int8* ptr = powers;
	  for (IntegralPowers::const_iterator p = i.powers().begin();
	       p != i.powers().end(); ++p, ++ptr) *ptr = *p;
	  
	  try
	    {
	      int value_size;
	      int8* value = 
		id.entry()._db->get(powers, i.powers().size(),0,-1,&value_size);
	      i.entry().assign(expression(value, value_size));
	      free(value);
	      i.entry()._stored = true;
	    }
	  catch (DATABASE_ERROR e)
	    {
	      if (e.code() != DATABASE::ENOITEM)
		{
		  cerr << "IntegralMap::integral: " << id.str()+_database_suffix
		       << " " << e << endl;
		  exit(1);
		}
	    }
	  
	  delete[] powers;
	}
    }

  return Integral(i);
}

/******************************************************************************
 *                                                                            *
 * expression                                                                 *
 *                                                                            *
 ******************************************************************************/

/**
 *
 * The expression has to have the same form as that generated by FORM after
 * bracketing of integrals, i.e.
 *
 * + integral1 * ( coefficient1)
 * + integral2 * ( coefficient2)
 * ...
 *
 * or
 *
 * 0
 *
 * integrals may be repeated, but the sign is assumed to be always positive and
 * the coefficient has to come after the integral and be surrounded with
 * parentheses. A more complicated parser may be written, but since the library
 * interfaces currently exclusively with FORM, there is no need for that.
 *
 */

// Transfer indentity given as an 'input' string into Expression object, which
// knows, which part of the identity is an integral, which is a coefficient and
// how those should be combined.
Expression
IntegralMap::expression(const string& input)
{
  Expression expr;
  int begin, end = -1;
  
  while ((begin = input.find_first_not_of("\n\t +", end+1)) != string::npos)
    {
      if (input[begin] == '0') return 0;
      
      end = input.find(")", begin)+1;

      Integral i = integral(input.substr(begin, end-begin));

      int parenthesis_level = 0;
      begin = input.find("(", end);
      end = begin;
      
      do
	{
	  end = input.find_first_of("()", end+1);
	  
	  if (input[end] == '(') ++parenthesis_level;
	  else --parenthesis_level;
	}
      while (parenthesis_level >= 0);
      
      Coefficient coeff(input.substr(begin+1, end-begin-1));

      expr.add(i, coeff);
    }

  return expr;
}

Expression
IntegralMap::expression(const char* buffer, int size)
{
  if (size == 1 && *buffer == 0) return 0;

  Expression expr;
  const char* ptr = buffer;
  const char* end = buffer+size;

  while (ptr < end)
    {
      int i_size = *((const int*) ptr);
      ptr += sizeof(int);
      Integral i = integral(ptr, i_size);
      ptr += i_size;

      int coeff_size = *((const int*) ptr);
      ptr += sizeof(int);
      Coefficient coeff(ptr, coeff_size);
      ptr += coeff_size;

      expr.add(i, coeff);
    }

  return expr;
}

/******************************************************************************
 *                                                                            *
 * update                                                                     *
 *                                                                            *
 ******************************************************************************/

/**
 *
 * The identity is parsed as an expression and simplified with the values that
 * have already been calculated. Subsequently it is solved for the largest
 * integral with respect to Integral::less_than(). In the second version
 * replacement rules are first applied to the input identity.
 *
 */

Integral
IntegralMap::update(Expression identity)
{
  identity.simplify();
  pair<Integral, Expression> result = identity.solve();
  
  if (result.first.defined()) result.first.assign(result.second);

  return result.first;
}

/******************************************************************************
 *                                                                            *
 * set_n_denominators                                                         *
 *                                                                            *
 ******************************************************************************/

/**
 *
 * Set the number of denominators for integrals with a given identifier. This
 * method is provided just to make the IntegralMap::LaportaOrdering work.
 *
 */

void
IntegralMap::set_n_denominators(const string& s, int n)
{
  const pair<string, IdentifierEntry> id_entry(s, IdentifierEntry(*this));
  pair<IdentifierPtr, bool> id_insert_stat = _identifiers.insert(id_entry);
  IdentifierPtr& id = id_insert_stat.first;
  
  // if the identifier has not been enocuntered yet, try to open a
  // database of associated integrals. The name is hardcoded to be 
  // <identifier>_database_suffix. The database is not created if it doesn't
  // exist.

  struct stat buf;
  if (id_insert_stat.second && !stat((s+_database_suffix).c_str(), &buf))
    {
      try
	{
	  id.entry()._db = 
	    new DB((s+_database_suffix).c_str(), DATABASE::OWRITER);
	}
      catch (DATABASE_ERROR e)
	{
	  cerr << "IntegralMap::set_n_denominators: " << s+_database_suffix
	       << " " << e << endl;
	  exit(1);
	}
    }

  id.entry()._n_denominators = n;
}

/******************************************************************************
 *                                                                            *
 * set_n_denominators                                                         *
 *                                                                            *
 ******************************************************************************/

int
IntegralMap::get_n_denominators(const string& s) const
{
  IdentifierConstPtr id(_identifiers.find(s));
  if (id != _identifiers.end())
    return id.entry()._n_denominators;
  else 
    return -1;
}

/******************************************************************************
 *                                                                            *
 * identifiers                                                                *
 *                                                                            *
 ******************************************************************************/

vector<string>
IntegralMap::identifiers() const
{
  vector<string> ids;

  for (IdentifierConstPtr id = _identifiers.begin();
       id != _identifiers.end(); ++id)
    ids.push_back(id.str());

  return ids;
}

/******************************************************************************
 *                                                                            *
 * init_iterator                                                              *
 *                                                                            *
 ******************************************************************************/

/**
 *
 * Initialization of the iterator over the integrals in memory. If the iterator
 * is not initialized then next_integral() and current_integral() have undefined
 * behaviour.
 *
 */

void
IntegralMap::init_iterator()
{
  if (n_integrals() == 0) return;

  IdentifierPtr first_identifier = _identifiers.begin();

  _current_integral =
    make_pair(first_identifier, first_identifier.entry()._integrals.begin());
}

/******************************************************************************
 *                                                                            *
 * next_integral                                                              *
 *                                                                            *
 ******************************************************************************/

bool
IntegralMap::next_integral()
{
  if (n_integrals() == 0) return false;

  if (++_current_integral.second ==
      _current_integral.first.entry()._integrals.end())
    {
      if (++_current_integral.first == _identifiers.end())
	{
	  init_iterator();
	  return false;
	}
      else
	{
	  _current_integral.second =
	    _current_integral.first.entry()._integrals.begin();
	  return true;
	}
    }

  return true;
}

/******************************************************************************
 *                                                                            *
 * current_integral                                                           *
 *                                                                            *
 ******************************************************************************/

Integral
IntegralMap::current_integral()
{
  if (n_integrals() == 0) return Integral();

  return _current_integral.second;
}

/******************************************************************************
 *                                                                            *
 * delete_unsolved                                                            *
 *                                                                            *
 ******************************************************************************/

/**
 *
 * An integral is considered unsolved if it is either not assigned and its
 * sum of numerator and denominator powers does not fit into the bounds, or
 * its value is expressed through integrals which do not fit into the bounds
 *
 * The actual deletions start with the assigned integrals, that are not 
 * referenced by others (this may happen if there are equivalence relations,
 * even though the integrals are in their simplified form).
 *
 */

void
IntegralMap::delete_unsolved(int max_sum_denominator_powers,
			     int max_sum_numerator_powers,
			     const string& identifier)
{
  IdentifierPtr begin, end;
  if (identifier == "")
    {
      begin = _identifiers.begin();
      end = _identifiers.end();
    }
  else
    {
      end = _identifiers.find(identifier);
      if (end == _identifiers.end()) return;
      begin = end++;
    }
    
  // simplification of the values has to come before erasing integrals
  // we also have to handle simplification of values on secondary storage.

  for (IdentifierPtr id = begin; id != end; ++id)
    for (IntegralPtr i = id.entry()._integrals.begin(); 
	 i != id.entry()._integrals.end(); ++i)
      if (i.entry().assigned()&& i.entry().simplify_value()&& i.entry()._stored)
	i.entry().write(id.entry()._db, i.powers());
  
  // some integrals may not be erased at first, because due to equivalence
  // (symmetry relations) they are refered by other integrals despite 
  // simplification above. Since the chains of equivalence relations after
  // simplification have only one equivalent integral, the operation has only
  // to be repeated twice. If this still leaves an unsolved integral, then 
  // it has to be referenced from outside the system, so we leave it as it is.

  for (int count = 0; count < 2; ++count)
    for (IdentifierPtr id = begin; id != end; ++id)
      {
	// the loop is constructed in a strange way, i.e. there is no 
	// incerementation inside for, but the pointer is incremented inside the
	// loop itself. This is necessary, because of the way iterators are 
	// invalidated after erasing.

	for (IntegralPtr i = id.entry()._integrals.begin(); 
	     i != id.entry()._integrals.end(); )
	  {
	    if (i.entry().assigned())
	      {
		vector<Integral> integrals = i.entry().value().integrals();
		
		bool solved = true;
		
		for (vector<Integral>::iterator j = integrals.begin(); 
		     j != integrals.end(); ++j)
		  {
		    if (j->sum_denominator_powers()> max_sum_denominator_powers 
			|| j->sum_numerator_powers()> max_sum_numerator_powers)
		      {
			solved = false;
			break;
		      }
		  }
		
		if (!solved && !i.entry()._ref_count)
		  {
		    IntegralPtr to_erase = i++;
		    id.entry()._integrals.erase(to_erase);
		    --_n_assigned_integrals;
		    continue;
		  }
	      }

	    ++i;
	  }
      }
  
  // unassigned integrals have to be erased last. The loop over the interals is
  // constructed as above.

  for (IdentifierPtr id = begin; id != end; ++id)
    for (IntegralPtr i = id.entry()._integrals.begin(); 
	 i != id.entry()._integrals.end(); )
      {
	if (!i.entry().assigned() && !i.entry()._ref_count && 
	    (i.powers().sum_denominator_powers() > max_sum_denominator_powers ||
	     i.powers().sum_numerator_powers() > max_sum_numerator_powers))
	  {
	    IntegralPtr to_erase = i++;
	    id.entry()._integrals.erase(to_erase);
	    --_n_unassigned_integrals;
	  }
	else
	  ++i;
      }
}

/******************************************************************************
 *                                                                            *
 * write                                                                      *
 *                                                                            *
 ******************************************************************************/

/**
 *
 * The assigned integrals are written to a database and subsequently removed
 * from memory if they are not referenced from outside the system.
 *
 */

void
IntegralMap::write(const string& identifier)
{
  IdentifierPtr begin, end;
  if (identifier == "")
    {
      begin = _identifiers.begin();
      end = _identifiers.end();
    }
  else
    {
      end = _identifiers.find(identifier);
      if (end == _identifiers.end()) return;
      begin = end++;
    }
    
  // first write everything to storage

  for (IdentifierPtr id = begin; id != end; ++id)
    {
      // the database is created if it didn't exist before, but stays open
      // afterwards, since it will be used for the next step in most cases.
      
      if (!id.entry()._db)
	try
	  {
	    string db_name = id.str()+id.entry()._integral_map._database_suffix;
	    id.entry()._db =
	      new DB(db_name.c_str(), DATABASE::OWRITER|DATABASE::OCREAT);
	  }
	catch (DATABASE_ERROR e)
	  {
	    cerr << "IntegralMap::IdentifierEntry::write: " << e << endl;
	    exit(1);
	  }
      
      for (IntegralPtr i = id.entry()._integrals.begin();
	   i != id.entry()._integrals.end(); ++i)
	if (i.entry().assigned() && !i.entry()._stored)
	  {
	    i.entry().write(id.entry()._db, i.powers());
	    i.entry()._stored = true;
	  }
    }

  // recursively remove all the integrals from memory, until no integral can
  // be removed because it is referenced from outside. we remove one integral
  // at a time for a given identifier, because it might happen that other
  // integrals will be removed invalidating the iterator.

  bool removed;

  do
    {
      removed = false;

      for (IdentifierPtr id = begin; id != end; ++id)
	for (IntegralPtr i = id.entry()._integrals.begin(); 
	     i != id.entry()._integrals.end(); ++i)
	  {
	    if (!i.entry()._ref_count)
	      {
		if (i.entry().assigned()) --_n_assigned_integrals;
		else --_n_unassigned_integrals;
		id.entry()._integrals.erase(i);
		removed = true;
		break;
	      }
	  }
    }
  while (removed);
}

/******************************************************************************
 *                                                                            *
 * print                                                                      *
 *                                                                            *
 ******************************************************************************/

void
IntegralMap::print(ostream& output, const string& identifier) const
{
  IdentifierConstPtr begin, end;
  if (identifier == "")
    {
      begin = _identifiers.begin();
      end = _identifiers.end();
    }
  else
    {
      end = _identifiers.find(identifier);
      if (end == _identifiers.end()) return;
      begin = end++;
    }

  for (IdentifierConstPtr id = begin; id != end; ++id)
    for (IntegralConstPtr i = id.entry()._integrals.begin(); 
	 i != id.entry()._integrals.end(); ++i)
      if (i.entry().assigned())
	{
	  // we handle simplification on secondary storage

	  if (i.entry().simplify_value() && i.entry()._stored)
	    i.entry().write(i.entry()._identifier.entry()._db, i.powers());

	  output << "fill " 
		 << i.entry()._identifier.str() << i.powers()
		 << " =\n\n" 
		 << i.entry().value() 
		 << "\n;\n\n";
	}
}

void
IntegralMap::print(ostream& output, 
		   int max_sum_denominator_powers,
		   int max_sum_numerator_powers, 
		   const string& identifier) const
{
  IdentifierConstPtr begin, end;
  if (identifier == "")
    {
      begin = _identifiers.begin();
      end = _identifiers.end();
    }
  else
    {
      end = _identifiers.find(identifier);
      if (end == _identifiers.end()) return;
      begin = end++;
    }
    
  for (IdentifierConstPtr id = begin; id != end; ++id)
    for (IntegralConstPtr i = id.entry()._integrals.begin(); 
	 i != id.entry()._integrals.end(); ++i)
      {
	if (i.entry().assigned())
	  {
	    // we handle simplification on secondary storage

	    if (i.entry().simplify_value() && i.entry()._stored)
	      i.entry().write(i.entry()._identifier.entry()._db, i.powers());
	    
	    vector<Integral> integrals = i.entry().value().integrals();
	    
	    bool solved = true;

	    for (vector<Integral>::iterator j = integrals.begin(); 
		 j != integrals.end(); ++j)
	      {
		if (j->sum_denominator_powers() > max_sum_denominator_powers 
		    || j->sum_numerator_powers() > max_sum_numerator_powers)
		  {
		    solved = false;
		    break;
		  }
	      }
	    
	    if (solved)
	      output << "fill " 
		     << i.entry()._identifier.str() << i.powers()
		     << " =\n\n" 
		     << i.entry().value() 
		     << "\n;\n\n";
	  }
      }
}

/******************************************************************************
 *                                                                            *
 * print_masters                                                              *
 *                                                                            *
 ******************************************************************************/

void
IntegralMap::print_masters(ostream& output,
			   int max_sum_denominator_powers,
			   int max_sum_numerator_powers,
			   const string& identifier) const
{
  IdentifierConstPtr begin, end;
  if (identifier == "")
    {
      begin = _identifiers.begin();
      end = _identifiers.end();
    }
  else
    {
      end = _identifiers.find(identifier);
      if (end == _identifiers.end()) return;
      begin = end++;
    }
    
  multimap<int, string> sorted_masters;

  for (IdentifierConstPtr id = begin; id != end; ++id)
    {
      const vector<IntegralConstPtr> masters = 
	id.entry().masters(max_sum_denominator_powers,max_sum_numerator_powers);

      for (vector<IntegralConstPtr>::const_iterator i = masters.begin(); 
	   i != masters.end(); ++i)
	{
	  const int n_denominators = i->powers().n_denominators();
	  const int identifier_length = i->entry()._identifier.str().size();
	  const int key = (n_denominators<<16)+identifier_length;

	  ostringstream master;
	  master << i->entry()._identifier.str() << i->powers();

	  sorted_masters.insert(make_pair(key, master.str()));
	}
    }

  for (multimap<int, string>::iterator master = sorted_masters.begin();
       master != sorted_masters.end(); ++master)
    {
      output << master->second << endl;
    }

  if (identifier == "")
    output << endl 
	   << sorted_masters.size() << " master integral(s) identified"
	   << endl;
}

/******************************************************************************
 *                                                                            *
 * print_database                                                             *
 *                                                                            *
 ******************************************************************************/

void
IntegralMap::print_database(ostream& output, const string& identifier)
{
  struct stat buf;
  if (stat((identifier+_database_suffix).c_str(), &buf))
    {
      cerr << "no database for " << identifier << endl;
      return;
    }

  try
    {
      DB db((identifier+_database_suffix).c_str());
      
      db.iterinit();
      
      for (;;)
	{
	  int key_size;
	  int8* key = db.iternext(&key_size);

	  output << "fill " << identifier << "(";
	  for (int i = 0; i < key_size; ++i)
	    {
	      if (i) output << ",";
	      output << static_cast<int>(key[i]);
	    }
	  output << ") =\n\n";

	  int value_size;
	  int8* value = db.get(key, key_size, 0, -1, &value_size);

	  output << expression(value, value_size)
		 << "\n;\n\n";

	  free(key);
	  free(value);
	}
    }
  catch (DATABASE_ERROR e)
    {
      if (e.code() != DATABASE::ENOITEM)
	{
	  cerr << "IntegralMap::print_database: " << identifier+_database_suffix
	       << " " << e << endl;
	}
      return;
    }
}

void
IntegralMap::print_database(ostream& output,
			    int max_sum_denominator_powers,
			    int max_sum_numerator_powers,
			    const string& identifier)
{
  struct stat buf;
  if (stat((identifier+_database_suffix).c_str(), &buf))
    {
      cerr << "no database for " << identifier << endl;
      return;
    }

  try
    {
      DB db((identifier+_database_suffix).c_str());
      
      db.iterinit();
      
      for (;;)
	{
	  int key_size;
	  int8* key = db.iternext(&key_size);

	  int value_size;
	  int8* value = db.get(key, key_size, 0, -1, &value_size);

	  Expression expr = expression(value, value_size);
	  vector<Integral> integrals = expr.integrals();
	  
	  bool solved = true;
	  
	  for (vector<Integral>::iterator i = integrals.begin(); 
	       i != integrals.end(); ++i)
	    {
	      if (i->sum_denominator_powers() > max_sum_denominator_powers 
		  || i->sum_numerator_powers() > max_sum_numerator_powers)
		{
		  solved = false;
		  break;
		}
	    }
	  
	  if (!solved) continue;
	  
	  output << "fill " << identifier << "(";
	  for (int i = 0; i < key_size; ++i)
	    {
	      if (i) output << ",";
	      output << static_cast<int>(key[i]);
	    }
	  output << ") =\n\n";

	  output << expression(value, value_size)
		 << "\n;\n\n";

	  free(key);
	  free(value);
	}
    }
  catch (DATABASE_ERROR e)
    {
      if (e.code() != DATABASE::ENOITEM)
	{
	  cerr << "IntegralMap::print_database: " << identifier+_database_suffix
	       << " " << e << endl;
	}
      return;
    }
}

/******************************************************************************
 *                                                                            *
 * sync_databases                                                             *
 *                                                                            *
 ******************************************************************************/

void
IntegralMap::sync_databases() const
{
  for (IdentifierConstPtr id=_identifiers.begin(); id!=_identifiers.end(); ++id)
    if (id.entry()._db) id.entry()._db->sync();
}

/******************************************************************************
 *                                                                            *
 * dump                                                                       *
 *                                                                            *
 ******************************************************************************/

/**
 *
 * Same as print(), but the system is not simplified and equivalence relations
 * are printed as they are in memory.
 *
 */

void
IntegralMap::dump(ostream& output) const
{
  for (IdentifierConstPtr id=_identifiers.begin(); id!=_identifiers.end(); ++id)
    {
      if (id != _identifiers.begin()) output << "\n";
      
      output << "Identifier: " << id.str() << "\n\n";

      int count = 0;

      output << "Assigned:\n\n";
      
      for (IntegralConstPtr i = id.entry()._integrals.begin(); 
	   i != id.entry()._integrals.end(); ++i)
	if (i.entry().assigned())
	  {
	    ++count;
	    output << i.entry()._identifier.str() << i.powers() << " =\n\n";
	    i.entry().value().dump(output);
	    output << "\n\n\n";
	  }

      if (!count) output << "none\n\n";

      count = 0;

      output << "Unassigned:\n\n";
      
      for (IntegralConstPtr i = id.entry()._integrals.begin(); 
	   i != id.entry()._integrals.end(); ++i)
	if (!i.entry().assigned())
	  {
	    ++count;
	    output << i.entry()._identifier.str() << i.powers() << "\n";
	  }

      if (!count) output << "none\n";
    }
}

/******************************************************************************
 *                                                                            *
 * IntegralPowers::n_denominators                                             *
 *                                                                            *
 ******************************************************************************/

int
IntegralMap::IntegralPowers::n_denominators() const
{
  int n = 0;
  for (IntegralPowers::const_iterator p = begin(); p != end(); ++p)
    if (*p > 0) ++n;

  return n;
}

/******************************************************************************
 *                                                                            *
 * IntegralPowers::sum_denominator_powers                                     *
 *                                                                            *
 ******************************************************************************/

int
IntegralMap::IntegralPowers::sum_denominator_powers() const
{
  int sum = 0;
  for (IntegralPowers::const_iterator p = begin(); p != end(); ++p)
    if (*p > 1) sum += *p-1;

  return sum;
}

/******************************************************************************
 *                                                                            *
 * IntegralPowers::sum_numerator_powers                                       *
 *                                                                            *
 ******************************************************************************/

int
IntegralMap::IntegralPowers::sum_numerator_powers() const
{
  int sum = 0;
  for (IntegralPowers::const_iterator p = begin(); p != end(); ++p)
    if (*p < 0) sum -= *p;

  return sum;
}

/******************************************************************************
 *                                                                            *
 * IntegralPowers::print                                                      *
 *                                                                            *
 ******************************************************************************/

void
IntegralMap::IntegralPowers::print(ostream& output) const
{
  for (IntegralPowers::const_iterator p = begin(); p != end(); ++p)
    {
      if (p == begin()) output << "(";
      else output << ",";
      output << static_cast<int>(*p);
    }
  output << ")";
}

/******************************************************************************
 *                                                                            *
 * IdentifierEntry::constructor                                               *
 *                                                                            *
 ******************************************************************************/

IntegralMap::IdentifierEntry::IdentifierEntry(IntegralMap& integral_map) : 
  _integral_map(integral_map),
  _n_denominators(0),
  _db(0)
{}

/******************************************************************************
 *                                                                            *
 * IdentifierEntry::destructor                                                *
 *                                                                            *
 ******************************************************************************/

IntegralMap::IdentifierEntry::~IdentifierEntry()
{
  if (_db) delete _db;
}

/******************************************************************************
 *                                                                            *
 * IdentifierEntry::masters                                                   *
 *                                                                            *
 ******************************************************************************/

vector<IntegralMap::IntegralConstPtr>
IntegralMap::IdentifierEntry::masters(int max_sum_denominator_powers,
				      int max_sum_numerator_powers) const
{
  vector<IntegralConstPtr> integrals;
  
  for (IntegralConstPtr i = _integrals.begin(); i != _integrals.end(); ++i)
    if (!i.entry().assigned() &&
	i.powers().sum_denominator_powers() <= max_sum_denominator_powers &&
	i.powers().sum_numerator_powers() <= max_sum_numerator_powers)
      {
	integrals.push_back(i);
      }

  return integrals;
}

vector<IntegralMap::IntegralPtr>
IntegralMap::IdentifierEntry::masters(int max_sum_denominator_powers,
				      int max_sum_numerator_powers)
{
  vector<IntegralPtr> integrals;
  
  for (IntegralPtr i = _integrals.begin(); i != _integrals.end(); ++i)
    if (!i.entry().assigned() &&
	i.powers().sum_denominator_powers() <= max_sum_denominator_powers &&
	i.powers().sum_numerator_powers() <= max_sum_numerator_powers)
      {
	integrals.push_back(i);
      }
  
  return integrals;
}

/******************************************************************************
 *                                                                            *
 * IntegralEntry assignement operator                                         *
 *                                                                            *
 ******************************************************************************/

IntegralMap::IntegralEntry&
IntegralMap::IntegralEntry::operator=(const IntegralEntry& i)
{
  if (this == &i) return *this;

  _identifier = i._identifier;
  delete _value;
  _value = new Expression(*i._value);
  _stored = i._stored;

  return *this;
}

/******************************************************************************
 *                                                                            *
 * IntegralEntry::assign                                                      *
 *                                                                            *
 ******************************************************************************/

void
IntegralMap::IntegralEntry::assign(const Expression& expr)
{
  if (!_value->defined() && expr.defined())
    {
      delete _value;
      _value = new Expression(expr);
      ++_identifier.entry()._integral_map._n_assigned_integrals;
      --_identifier.entry()._integral_map._n_unassigned_integrals;
    }
}

/******************************************************************************
 *                                                                            *
 * IntegralEntry::write                                                       *
 *                                                                            *
 ******************************************************************************/

void
IntegralMap::IntegralEntry::write(DB* db, const vector<Power>& pow) const
{
  if (assigned())
    {
      try
	{
	  int8* powers = new int8[pow.size()];
	  int8* ptr = powers;
	  for (IntegralPowers::const_iterator p = pow.begin();
	       p != pow.end(); ++p, ++ptr) *ptr = *p;
	  
	  ResizableBuffer value;
	  const int value_size = _value->write(value);
	
	  db->put(powers,
		  pow.size(),
		  value._begin, 
		  value_size, 
		  DATABASE::DOVER);

	  delete[] powers;
	}
      catch (DATABASE_ERROR e)
	{
	  cerr << "IntegralMap::IntegralEntry::write: " << e << endl;
	  exit(1);
	}
    }
}
